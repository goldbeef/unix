kernel's function
    process schedule
    memory manage 
    file-system
    process manage
    access for device
    network 
    system-api
------------------------------------------------
program run-state
    kernel-state
    user-state
shell 
    sh 
    bash 
    csh
    ksh
------------------------------------------------
user and group
    user 
        user-id
        home-dirctory
        login-shell
        ---------------------
        useradd goldbeef [-d home-dirctory]
        passwd golddbeef 
    group
        group-id
        group-name
    root
------------------------------------------------
file 
    file-type
    file-path
    link
        symbol-link
            cross file-system
        hard-link
    ---------------------
    file-auth
        u,g,o
        r,w,x
    ---------------------
    file i/o mode
        treated as byte stream 
------------------------------------------------
process 
    .text 
    .data 
    .bss 
    .stack 
    .heap 
    ---------------------
    pid, ppid
    exec ...
    exit
    _exit
    ---------------------
    real user-id 
    real group-id 

    effective user-id 
    effective group-id
    ---------------------
    init process
        pid = 1
        /sbin/init 
    ---------------------
    daemon process 
        ppid = 1
    ---------------------
    environment-list
        export key=value 
    ---------------------
    mmap
        file-mmaping
            for file i/o 
            for IPC
        anonymous-mapping
            for IPC
            memory alloc
------------------------------------------------
static-lib 
    waste for disk and memory
    problem for software update
shared-lib 
    safe for disk and memory
    easy for software update
------------------------------------------------
IPC (internal process communication)
    signal
    pipe
    fifo 
    socket
    file-lock
    mesage-queue
    semaphore
    shared-memory
------------------------------------------------
signal 
    SIG_xxx
    ---------------------
    signal control
        default operation
        ignore
        signal handler
    ---------------------
------------------------------------------------
thread
/proc file-system 
------------------------------------------------
system-api
    call system-api
    trigger user-state to kernel-state
    int 80
    return back to user-state
------------------------------------------------
glibc 
    ldd programname|grep glibc 
    /lib/i386-linux-gnu/libc.so.6 
    ---------------------
    __GLIBC__
    __GLIBC_MINOR__
------------------------------------------------
error-process 
    #include <errno.h>
    extern int errno;
    ---------------------
    void perror(const char* msg);
    char* strerror(int errno);
    ---------------------
    for thread 
        erron is a MACORO
------------------------------------------------
transplant for system-api programming
    use test macoro
        #define _BSD_SOURCE  
        ---------------------
        gcc -D_BSD_SOURCE
    ---------------------
    system-type print  
        typedef int pid_t;
        printf("pid[%d]", (int)pid)
    system-type init 
        
------------------------------------------------
file I/O
    --------------------- 
    FILE *freopen(const char *path, const char *mode, FILE *stream);
    ---------------------
    file-discriptor
        0   STDIN_FILENO    stdin
        1   STDOUT_FILENO   stdout 
        2   STDERR_FILENO   stderr 
    ---------------------
    file system-api
        int open(const char *pathname, int flags);
        int open(const char *pathname, int flags, mode_t mode);
            flags: 
                O_RDONLY 
                O_WRONLY
                O_RDWR 
                O_CLOEXEC
                    close-on-exec
                O_CREATE
                O_EXCL
                    along with O_CREATE to check if exist
                O_NOCTTY
                O_NONBLOCK
        int creat(const char *pathname, mode_t mode);
        ssize_t read(int fd, void *buf, size_t count);
        ssize_t write(int fd, const void *buf, size_t count);
        int close(int fd);
        off_t lseek(int fd, off_t offset, int whence);
            whence
                SEEK_SET
                SEEK_CUR
                SEEK_END
        ---------------------
    ---------------------
    file hole 
        exceed to end of file by lseek 
        ---------------------
        not wate disk-block
    ---------------------
------------------------------------------------
deep into file-i/o
    race-condition
    atom-operation
    ---------------------
    create file atom-operation
        open, O_EXCL|O_CREATE
    append data atom-operation
        open, O_APPEND
    ---------------------
    file control operation
        int fcntl(fd, int cmd, ...)
            cmd 
                F_GETFL
                F_SETFL
    ---------------------
    内核维护的文件相关数据结构
        文件描述服表：
            process-level
            ---------------------
            file-discriptor mark 
                close-on-exec
            file-handler ref
        打开文件表：
            OS-level
            ---------------------
            file-offset
            file-stat-flag
                open 
            file-access-mode
            signal-related set 
            i-node ref 
        i-node表：
            file-system-level
            ---------------------
            file-type
            lock-list 
            file-basic-property
    ---------------------
    复制文件表述符
        int dup(int oldfd);
        
        int dup2(int oldfd, int newfd);
        int fcntl(int oldfd, F_DUPFD, int newfd);

        int dup3(int oldfd, int newfd, int flags)
            O_CLOEXEC
        int fcntl(...);
            F_DUPFD_CLOEXEC
    ---------------------
    ssize_t pread(int fd, void* buff, size_t count, off_t offset);
    ssize_t pwrite(int fd, void* buff, size_t count, off_t offset);
    ---------------------
    ssize_t readv(int fd, const struc iovec* iov, int iovcount);
    ssize_t writev(int fd, const struc iovec* iov, int iovcount);
        --------------------- 
        struct iovec 
        {
            void* iov_base;
            size_t iov_len;
        }
    -------------------------
    ssize_t preadv(int fd, const struc iovec* iov, int iovcount, off_t offset);
    ssize_t owritev(int fd, const struc iovec* iov, int iovcount, off_t offset);
    ---------------------
    int truncate(const char* pathname, off_t length);
    int ftruncate(int fd, off_t length);
        //may result in file-whole
    -------------------------
    large-file-i/o
        LFS-API
            xxx64(...)
        ---------------------
        FILE_OFFSET_BITS=64
            #define FILE_OFFSET_BITS 64 
            gcc -D_FILE_OFFSET_BITS=64 
    ---------------------
    /dev/fd/xx  --> /proc/self/fd/xx 
    /dev/stdxxx --> /proc/self/fd/xxx 
        use in shell: no need to special control '-'
            ls |diff /dev/fd/0 oldfilleList
    -------------------------
    int mkstemp(char* template);
        easy to use 
    FILE* tmpFile(void);

------------------------------------------------
process
    pid_t getpid(void);
        pid_t num: linux set max 32767
            /process/sys/kernel/max_pid
            once up to max-limit, then reset to 300 (1-300 for special use)
        process-status
            /proc/pidnum/status
                include process-status in detail
    pid_t getppid(void);
        pstree [-p pid]
            get proces-tree
    ---------------------
    process-addr-space
        text
        data
        bss
        stack
        heap
        argv/env
        kernel-space 
    size elf-file
        get sections and size 
    ---------------------
    virtual-addr-space
        use spatial-locality and temporal-locality
        ---------------------
        page-size
            4094
        process 
            page-table
                store in RAM-AREA or SWAP-AREA
                virtual-addr-space --> physiacal-page , by PMMU(page memory manage unit)
    ---------------------
    stack
    ---------------------
    argc/argv 
        /proc/pidnum/cmdline
    -------------------------
    environment-list
        add env-var long time:
            SHELL=/bin/bash
            export SHELL 

            exprot SHELL=/bin/bash 
        add env-var tmporal time:
            key1=val1 key2=val2 programname
        ---------------------
        get env-var
            global var 
                char** environ;

            main(int argc, char* argv[], char* envp[])
            
            char* getenv(const char*  name);

        ---------------------
        set env-var
            int putenv(char* string);
                string not stored in stack 
            int setenv(const char* name, const char* value, int overwrite);
        ---------------------
        unset env-var 
            int unitenv(const char* name);
            int clearenv(void);
    ---------------------
    no-local jump
        int setjmp(jmp_buf env);
        void longjmp(jump_buf env, int val);
        ---------------------
        abuse longjmp
            jump to a returned-stack-frame: will crash
        use volatile
            avoid compiler to doing some-perf
------------------------------------------------
memory-alloc
    program-break
        int brk(void* end_data_segment);
        void *sbrk(intptr_t increment);
    ---------------------
    heap-memory-alloc
        void* malloc(size_t size);
            easy to use 
        void  free(void* ptr);
            will not decrease program-break generally
        ---------------------
        implement
            malloc 
                alloc form avaliable-free-queue
            free 
                free to avaliable-free-queue
        ---------------------
        malloc-debug tool
            mtrace(), muntrace()
                with MALLOC_TRACE
            mcheck(), mprobe()
                with cc-lmcheck
            MALLOC_CHECK
        ---------------------
        mallopt()
        mallinfo()
    ---------------------
    void* calloc(size_t numitems, size_t size);
    void* realloc(void* ptr, size_t size);
    ---------------------
    allign
        void* memalign(size_t boundary, size_t size);
        int posix_memalign(void** memptr, size_t allign, size_t size);
    ---------------------
    void* alloc(size_t size);
        //from stack to get memory
        //should not use in function-param
        // foo(alloc(100));
        ---------------------
        special use 
            in longjmp to avoid memory-sleek
------------------------------------------------
file-system 
    device-type 
        character-device
        block-device
    device-id 
        primary-device-id  (12 bits)
        auxiliary-device-id (20 bits)
    device-file --> i-node's device-id --> drive-program
    -------------------------
    disk 
        disk-device
        disk-partition
            file-system 
            data-area
            swap-area 
    -------------------------
    ext2-file-system 
        intro-block | super-block | i-node-list | data-block
        ---------------------
        i-node 
            file-type
            file-auth 
            ..
            hard-link
            file-size 
            file-block
        ---------------------
        i-node entry: total 15 ptr 
            ptr[0-11] 
                point to data-block 
            ptr[12] 
                point to IPB 
            ptr[13]
                point to 2IPB 
            ptr[14]
                point to 3IPP
        max-file size: 
            (data-block-size/ptr-size)^3*data-block-size
        ---------------------
        weakness
            check of file-system with low performance
    -------------------------
    virtual-file-system (VFS)
    -------------------------
    log-file-system
        high-performance
        ---------------------
        ext3
        ext4
    -------------------------
    mount  device directory
        /proc/mounts 
            linux 
        /etc/fstab 
        /etc/mtab 
        ---------------------
        #include <sys/mount.h>
        int mount(const char* source, const char* target, const char* fstype, long mountflags, const void* data);
        int umount(const char* target)
        int umount2(const char* target, int flags)
        ---------------------
        advanced-mount-character
            one file-system  --> multi-mount-points
            mount-flags for once 
            bind-mount 
                mount --bind src dst
                used for jail
            rec-mount
                mount --rbind
    ---------------------
    virtual-addr-space
        tmpfs
            based on memory /swap 
            used for system-V-IPC | posix-IPC
        ---------------------
        mount -t tmpfs src dst
    ---------------------
    statvfs
    fstatvfs
        

        
